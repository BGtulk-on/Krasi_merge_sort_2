# MERGE SORT - ЗАДАЧИ 
## Задача 1: Основна реализация и измерване на производителност  
Цел: Да се реализира класическият алгоритъм Merge Sort (сортиране чрез сливане) и да се измери времето му за изпълнение. 
Описание: 
1. Напишете Java клас, който съдържа метод mergeSort(int[] arr, int left, int right) и помощен метод merge(int[] arr, int left, int mid, int right) . 
2. Реализирайте рекурсивната логика на разделяне в mergeSort и логиката на сливане на два сортирани подмасива в merge . 
3. В main метода генерирайте масиви с различен брой елементи (например за 1000, 10 000, 100 000 и 1 000 000) със случайни цели числа. 
4. За всеки размер на масива, измерете времето, необходимо за сортирането му с вашия mergeSort метод. Можете да използвате System.nanoTime() или 
System.currentTimeMillis() преди и след извикването на сортиращия метод. 
5. Сравнете времето за изпълнение на вашата реализация с вградения метод Arrays.sort(arr) за същите масиви. Очаквани резултати: Работеща реализация на Merge Sort и изведени времена за сортиране на масиви с различните размери в табличен вид [ брой елементи] [ време за изпълнение
]. Кратък анализ на зависимостта между времето за изпълнение и размера на масива (трябва да е близо до O(n log n)). 

## Задача 2: Броене на инверсии 
Цел: Да се модифицира алгоритъмът Merge Sort, така че освен да сортира масив, да преброи броя на инверсиите в него. Описание: 
Инверсия в един масив arr е двойка индекси (i, j) , за която е изпълнено i < j и arr[i] > arr[j] . С други думи, това е двойка елементи, които са в "грешен" ред един спрямо друг и трябва да си разменят местата. 
1. Вземете вашата реализация на Merge Sort от Задача 1. 2. Модифицирайте методите mergeSort и merge , така че да връщат броя на инверсиите, открити в съответния етап. 3. Ключовата модификация е в метода merge : когато елемент от десния подмасив ( arr[j] ) бъде преместен в обединения масив преди елемент от левия подмасив ( arr[i] ), това означава, че arr[j] формира инверсия с всички останали елементи в левия подмасив (от arr[i] нататък). Трябва да добавите броя на тези оставащи елементи към общия брой инверсии. 
4. Рекурсивният метод mergeSort трябва да събира броя на инверсиите, върнати от рекурсивните извиквания за лявата и дясната половина, плюс броя на инверсиите, открити по време на фазата на сливане (върнати от merge ). 
5. В main метода тествайте функцията с същите масиви, както в Задача 1 изведете както сортирания масив, така и изчисления брой инверсии в третата колона на описаната в Задача 1 таблица [ брой елементи] [ време за изпълнение ] [ брой инверсии ].
Очаквани резултати: Работеща програма, която коректно сортира масив и изчислява общия брой инверсии в него, използвайки модифициран Merge Sort.
